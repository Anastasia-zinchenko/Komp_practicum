РОССИЙСКИЙ УНИВЕРСИТЕТ ДРУЖБЫ НАРОДОВ ИМЕНИ ПАТРИСА ЛУМУМБЫ
Факультет физико-математических и естественных наук




Компьютерный практикум
Лабораторная работа №1
«Численные методы поиска корней уравнений»




Студент	Зинченко Анастасия Романовна
Группа	НБИбд-01-23
	







Москва
2024
 
Оглавление 
1.	Введение.	3
2.	Теория.	4
2.1.	Комплексные числа.	4
2.2.	Метод дихотомии.	5
2.3.	Метод итерации.	5
2.4.	Метод хорд.	6
2.4.1.	Геометрическое описание метода секущих	6
2.4.2.	Алгебраическое описание метода секущих	6
2.5.	Метод Ньютона	7
3.	Программы	7
Заключение.	15
Литература	16
 
 
Введение.

В данной работе будут рассмотрены численные методы поиска корней уравнений. Целью данной работы является работа с комплексными числами и программирование различных методов поиска корней уравнений.
В первой части работы приведена теория, касающаяся комплексных чисел и методов дихотомии, итераций, хорд и Ньютона.
Во второй части работы приведены примеры программ работы с комплексными числами и методами поиска корней уравнений.
 

Теория.
 Комплексные числа.
Комплексные числа (от лат. complexus — связь, сочетание) — числа вида a + bi, где  a,b — вещественные числа, i — мнимая единица, то есть число, для которого выполняется равенство: i2 = -1. Множество комплексных чисел обычно обозначается символом ℂ. Вещественные числа можно рассматривать как частный случай комплексных, они имеют вид a + 0i. Главное свойство  ℂ — в нём выполняется основная теорема алгебры, то есть любой многочлен n-й степени (n ≥ 1) имеет n корней. Доказано, что система комплексных чисел логически непротиворечива.
Так же как и для вещественных чисел, для комплексных чисел определены операции сложения, вычитания, умножения и деления. Однако многие свойства комплексных чисел отличаются от свойств вещественных чисел; например, нельзя указать, какое из двух комплексных чисел больше или меньше. Удобно представлять комплексные числа a+bi точками на комплексной плоскости; например, для изображения сопряжённых чисел используется операция отражения относительно горизонтальной оси. Альтернативное представление комплексного числа в тригонометрической записи оказалось полезным для вычисления степеней и корней. Функции комплексного аргумента изучаются в комплексном анализе.
Первоначально идея о необходимости использования комплексных чисел возникла в результате формального решения кубических уравнений, при котором в формуле Кардано под знаком квадратного корня получалось отрицательное число. Большой вклад в исследование комплексных чисел внесли такие математики как Эйлер, который ввёл общепризнанное обозначение i для мнимой единицы, Декарт, Гаусс. Сам термин «комплексное число» ввёл в науку Гаусс в 1831 году.
Уникальные свойства комплексных чисел и функций нашли широкое применение для решения многих практических задач в различных областях математики, физики и техники: в обработке сигналов, теории управления, электромагнетизме, теории колебаний, теории упругости и многих других. Преобразования комплексной плоскости оказались полезны в картографии и гидродинамике. Современная физика полагается на описание мира с помощью квантовой механики, которая опирается на систему комплексных чисел.
Известно также несколько обобщений комплексных чисел — например, кватернионы.
Метод дихотомии.
Правильное решение уравнения методом половинного деления возможно лишь в том случае, если известно, что на заданном интервале имеется корень и он является единственным. Это совсем не означает что метод дихотомии может использоваться только для решения линейных уравнений. Для нахождения корней уравнений более высокого порядка методом половинного деления необходимо сначала отделить корни по отрезкам. Процесс отделения корней осуществляется путем отыскания первой и второй производной от функции и приравнивании их нулю f'(x)=0 и f''(x)=0. Далее определяются знаки f(x) в критических и граничных точках. Интервал, где функция меняет знак |a,b|, где f(a)*f(b)< 0.
Метод итерации.
Метод итерации или метод простой итерации — численный метод решения системы линейных алгебраических уравнений. Суть метода заключается в нахождении по приближённому значению величины следующего приближения, являющегося более точным.
Метод позволяет получить значения корней системы с заданной точностью в виде предела последовательности некоторых векторов (в результате итерационного процесса). Характер сходимости и сам факт сходимости метода зависит от выбора начального приближения корня.
Метод хорд.

Метод хорд — итерационный численный метод приближённого нахождения корня уравнения.
Геометрическое описание метода секущих
Будем искать нуль функции f(x). Выберем две начальные точки C1(x1;y1)  и C2(x2;y2) и проведем через них прямую. Она пересечет ось абсцисс в точке (x3;0). Теперь найдем значение функции с абсциссой x3. Временно будем считать x3 корнем на отрезке [x1;x2]. Пусть точка C3 имеет абсциссу x3 и лежит на графике. Теперь вместо точек C1 и C2 мы возьмём точку C3 и точку C2. Теперь с этими двумя точками проделаем ту же операцию и так далее, то есть будем получать две точки Cn+1 и Cn и повторять операцию с ними. Отрезок, соединяющий последние две точки, пересекает ось абсцисс в точке, значение абсциссы которой можно приближённо считать корнем. Эти действия нужно повторять до тех пор, пока не получим значение корня с нужным приближением.
Алгебраическое описание метода секущих
Пусть x1, x2  — абсциссы концов хорды, f(x)=0 — уравнение функции, решаемое методом секущих. Найдём коэффициенты k и b из системы уравнений
 {█(f(x1)=kx1+b@f(x2)=kx2+b)┤

Вычтем из первого уравнения второе:
f(x1)-f(x2)=k(x1-x2)
затем найдём коэффициенты k и b:
k=(f(x2)-f(x1))/(x2-x1)
тогда
b=f(x1)-(f(x2)-f(x1))x1/(x2-x1)
Уравнение принимает вид
y=(f(x2)-f(x1))/(x2-x1)(x-x1)+f(x1)
Таким образом, теперь можем найти первое приближение к корню, полученное методом секущих:
x3=x1-((x2-x1)f(x1))/(f(x2)-f(x1))
Теперь возьмём координаты   и   и повторим все проделанные операции, найдя новое приближение к корню. Таким образом, итерационная формула метода секущих имеет вид:
x_(i+1 )=〖 x〗_(i-1) - (f(〖 x〗_(i-1))(〖 x〗_i-〖 x〗_(i-1)))/(f(〖 x〗_i )-f(〖 x〗_(i-1)))
Повторять операцию следует до тех пор, пока  〖| x〗_i-〖 x〗_(i-1) | не станет меньше или равно заданному значению погрешности.
Метод Ньютона
Метод Ньютона, алгоритм Ньютона (также известный как метод касательных) — это итерационный численный метод нахождения корня (нуля) заданной функции. Метод был впервые предложен английским физиком, математиком и астрономом Исааком Ньютоном (1643—1727). Поиск решения осуществляется путём построения последовательных приближений и основан на принципах простой итерации. Метод обладает квадратичной сходимостью. Модификацией метода является метод хорд и касательных. Также метод Ньютона может быть использован для решения задач оптимизации, в которых требуется определить ноль первой производной либо градиента в случае многомерного пространства.
Программы
№ 1 (С++)

//Complex numbers
#include <iostream>
#include <math.h>
#include <complex>
using namespace std;
int main ()
{
complex <double> z1 (-1.0, 1.0);
complex <double> z2 (-2.0, -2.0);
complex <double> z3 (-1.0, 1.0);
double x = -1.0;
double y = 1.0;
double q = pow((pow(x,2) + pow(y,2)),(1/2));
double u = atan (y/x);
std::complex<double> s = z1 + z2;//сумма комплексных чисел
std::complex<double> r = z1 - z2;//разность комплексных чисел
std::complex<double> d = z1 / z2;//деление комплексных чисел
std::complex<double> p = z1 * z2;//умножение комплексных чисел
cout << s;
cout << r;
cout << p;
cout << d;
cout << pow (z3, 4);//четвертая степень комплексного числа
cout << pow (z3, (1/3));//корень третьей степени комплексного числа 

return 0;
}

№ 1 (Python)
#Complex numbers
import math
z1 = -1 + 1j 
z2 = -2 -2j
z3 = -1 + 1j
s = z1 + z2#сумма комплексных чисел
r = z1 - z2#разность комплексных чисел
p = z1 * z2#умножение комплексных чисел
d = z1 / z2#деление комплексных чисел
print (s)
print (r)
print (p)
print (d)
print (pow (z3, 4))#четвертая степень комплексного числа
print (pow (z3, (1/3)))#корень третьей степени комплексного числа

№ 2 (метод дихотомии С++)
#include <iostream>
#include <cmath>

double f(double x) {
    return log(x) + pow(x + 1, 3);
}

double findRoot(double a, double b, double epsilon) {
    if (f(a) * f(b) >= 0) {
        std::cout << "Root is not in the given interval." << std::endl;
        return -1;
    }

    double c;
    
    while ((b - a) >= epsilon) {
        c = (a + b) / 2;

        if (f(c) == 0.0) {
            break;
        } else if (f(c) * f(a) < 0) {
            b = c;
        } else {
            a = c;
        }
    }

    return c;
}

int main() {
    double a = 0.1;
    double b = 1.0;
    double epsilon = 1e-6;

    double root = findRoot(a, b, epsilon);

    if (root != -1) {
        std::cout << "Root: " << root << std::endl;
        std::cout << "f(root): " << f(root) << std::endl;
    }

    return 0;
}


№ 2 (метод дихотомии Python)
def f(x):
    return np.log(x) + (x + 1)**3

def bisection_method(a, b, eps):
    if f(a) * f(b) >= 0:
        print("Метод дихотомии не применим. На концах отрезка функция имеет одинаковый знак.")
        return None
    while (b - a) > eps:
        c = (a + b) / 2
        if f(c) == 0:
            return c
        elif f(c) * f(a) < 0:
            b = c
        else:
            a = c
    return (a + b) / 2

a = 0.1
b = 3
eps = 1e-6

root = bisection_method(a, b, eps)
if root:
    print("Корень уравнения: ", root)
№ 2 (метод итераций С++)
#include <iostream>
#include <cmath>

using namespace std;

double f(double x) {
    return log(x) + pow(x + 1, 3);
}

double df(double x) {
    return 1 / x + 3 * pow(x + 1, 2);
}

double iterate(double x0, double epsilon) {
    double x = x0;
    while (true) {
        double x_next = x - f(x) / df(x);
        if (abs(x_next - x) < epsilon) {
            return x_next;
        }
        x = x_next;
    }
}

int main() {
    double x0 = 0.5;  // Начальное приближение
    double epsilon = 1e-6;
    
    double root = iterate(x0, epsilon);
    
    cout << "Корень уравнения: x = " << root << endl;
    
    return 0;
}

№ 2 (метод итераций Python)
import math

def g(x):
    return -1 - (math.log(x) / 3) ** 2

def solve_by_iteration(epsilon):
    x0 = 0.5  # начальное приближение
    x1 = g(x0)
    while abs(x1 - x0) >= epsilon:
        x0 = x1
        x1 = g(x0)
    return x1

epsilon = 1e-6
solution = solve_by_iteration(epsilon)
print(f"Корень уравнения: {solution}")

№ 2 (метод хорд С++)
#include <iostream>
#include <cmath>

using namespace std;

double f(double x) {
    return log(x) + pow((x + 1), 3);
}

double chordMethod(double a, double b, double epsilon) {
    double x0 = a;
    double x1 = b;
    while (fabs(x1 - x0) > epsilon) {
        x0 = x1 - f(x1) * (x1 - a) / (f(x1) - f(a));
        a = x1;
        x1 = x0;
    }
    return x1;
}

int main() {
    double a = 1.0; // Начальное приближение интервала
    double b = 2.0; // Конечное приближение интервала
    double epsilon = 1e-6; // Точность

    double root = chordMethod(a, b, epsilon);

    cout << "Корень уравнения: " << root << endl;

    return 0;
}

№ 2 (метод хорд Python)
import math

def f(x):
    return math.log(x) + (x + 1)**3

def false_position_method(x0, x1, eps):
    max_iter = 1000
    iter = 0
    
    while abs(x1 - x0) > eps:
        x = x1 - f(x1) * (x1 - x0) / (f(x1) - f(x0))
        x0, x1 = x1, x
        iter += 1
        
        if iter > max_iter:
            print("Невозможно найти корень с заданной точностью, превышено максимальное количество итераций")
            return None

    return x

x0 = 0.5
x1 = 1.0
epsilon = 1e-6

root = false_position_method(x0, x1, epsilon)
if root is not None:
    print("Корень уравнения: {:.6f}".format(root))

№ 2 (метод Ньютона С++)
#include <iostream>
#include <cmath>

double f(double x) {
    return log(x) + pow((x + 1), 3);
}

double f_prime(double x) {
    return 1/x + 3*pow((x + 1), 2);
}

double newton_method(double x0, double epsilon) {
    double x = x0;
    int iteration = 0;
    
    do {
        x0 = x;
        x = x0 - f(x0) / f_prime(x0);
        
        iteration++;
    } while(abs(x - x0) >= epsilon);
    
    std::cout << "Root: " << x << std::endl;
    std::cout << "Number of iterations: " << iteration << std::endl;
    
    return x;
}

int main() {
    double x0 = 0.1; // Изначальное приближение для метода Ньютона
    double epsilon = 1e-6;
    
    newton_method(x0, epsilon);
    
    return 0;
}

№ 2 (метод Ньютона Python)
import math

def f(x):
    return math.log(x) + (x + 1)**3

def f_prime(x):
    return 1/x + 3*(x + 1)**2

def newton_method(f, f_prime, x0, epsilon):
    x1 = x0 - f(x0) / f_prime(x0)
    while abs(x1 - x0) >= epsilon:
        x0 = x1
        x1 = x0 - f(x0) / f_prime(x0)
    return x1

# Начальное приближение
x0 = 1

# Точность
epsilon = 1e-6

# Нахождение корня уравнения
root = newton_method(f, f_prime, x0, epsilon)
print(f"Корень уравнения: {root}")
print(f"Значение функции в корне: {f(root)}")
Заключение.
В данной работе были рассмотрены численные методы поиска корней уравнений. Целью данной работы было работа с комплексными числами и программирование различных методов поиска корней уравнений.
В первой части работы приведена теория, касающаяся комплексных чисел и методов дихотомии, итераций, хорд и Ньютона.
Во второй части работы приведены программы работы с комплексными числами и методами поиска корней уравнений. 
Литература
	Дихотомия — Википедия (wikipedia.org)http://ru.wikipedia.org/wiki/%D0%9C%D0%B5%D1%82%D0%BE%D0%B4_%D0%B7%D0%BE%D0%BB%D0%BE%D1%82%D0%BE%D0%B3%D0%BE_%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D1%8F
	Метод итерации — Википедия (wikipedia.org)
	Метод хорд — Википедия (wikipedia.org)
	Метод Ньютона — Википедия (wikipedia.org)

